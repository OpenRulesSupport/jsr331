%-----------------------------------------------------------------------------%
% The sequence of values in array 'x' (which must all be in the range 1..S)
% is accepted by the DFA of 'Q' states with input 1..S and transition
% function 'd' (which maps (1..Q, 1..S) -> 0..Q)) and initial state 'q0'
% (which must be in 1..Q) and accepting states 'F' (which all must be in
% 1..Q).  We reserve state 0 to be an always failing state.
%-----------------------------------------------------------------------------%
predicate regular(array[int] of var int: x, int: Q, int: S,
                  array[int,int] of int: d, int: q0, set of int: F) =
    assert(Q > 0,
        "regular: 'Q' must be greater than zero",
    
    assert(S > 0,
        "regular: 'S' must be greater than zero",
    
    assert(index_set_1of2(d) = 1..Q /\ index_set_2of2(d) == 1..S,
        "regular: the transition function 'd' must be [1..Q,1..S]",

    assert(forall([d[i, j] in 0..Q | i in 1..Q, j in 1..S]),
        "regular: transition function 'd' points to states outside 0..Q",

        % Nb: we need the parentheses around the expression otherwise the
        % parser thinks it's a generator call!
    assert((q0 in 1..Q),
        "regular: start state 'q0' not in 1..Q",
    
    assert(F subset 1..Q,
        "regular: final states in 'F' contain states outside 1..Q",

	let {
	  array[1..card(index_set_1of2(d))*card(index_set_2of2(d))] of int : d2 = 
	  	[ d[i, j] | i in index_set_1of2(d), j in index_set_2of2(d)]
	}
	in 
	  jacop_regular(x, Q, S, d2, q0, F,  min(index_set_2of2(d)))
%	  jacop_regular(x, Q, S, d, q0, F,  min(index_set_2of2(d)))


%        let {
%            % d2 is the same as d, except we add one extra transition for
%            % each possible input;  each extra transition is from state zero
%            % to state zero.  This allows us to continue even if we hit a
%            % non-accepted input.
%            array[0..Q, 1..S] of int: d2 =
%                array2d(0..Q, 1..S,
%                  [if i == 0 then 0 else d[i, j] endif | i in 0..Q, j in 1..S]),
%        
%            % If x has index set m..n, then a[m-1] holds the initial state
%            % (q0), and a[i+1] holds the state we're in after processing
%            % x[i].  If a[n] is in F, then we succeed (ie. accept the
%            % string).
%              int: m = min(index_set(x)),
%              int: n = max(index_set(x)) + 1,
%              array[m..n] of var 0..Q: a
%            } in
%        a[m] = q0 /\                    % Set a[0].
%        forall(i in index_set(x)) (
%            x[i] in 1..S /\             % Do this in case it's a var.
%            a[i+1] = d2[a[i], x[i]]     % Determine a[i+1].
%        a[n] in F                       % Check the final state is in F.

    ))))));

predicate jacop_regular(array[int] of var int: x, int: Q, int: S,
                        array[int] of int: d, int: q0, set of int: F, int: min_index);
